## Android Basics

- Concepts introduced in slide

- Demo at the end



## What a program need to run as an android app?

- Access to the Android OS functionalities (via Android SDK or other means)

- Digital certificate to sign the app, to publish it on play store



## How does an android app runs?

- Android OS runs each app as unique user

- The OS sets permission for each app's files to it's assigned unique user

- Each process runs in its own VM (Android Runtime), app code runs in isolation from other app



## What can an app access?

- An app can access its own generated data

- An app cannot access other app's data by default

- Each app needs to be granted explicit permission by user to access device data



## Essential building blocks of an app

- Manifest

- App Components

  - Activity

  - Service

  - Broadcast Receiver

  - Content Provider

- Intent



## Manifest

- Every app should have `AndroidManifest.xml` in its root project source

- It describes your app info and configuration to the OS, build tools, and google play

- Non-runtime permissions, App components, and Device compatibility should be declared here


```[2-3|4-6|7-11]
<manifest>
    <uses-permission 
        android:name="android.permission.SEND_SMS"/>
    <uses-feature 
        android:name="android.hardware.sensor.compass"
        android:required="true" />
    <application>
        <activity 
            android:name="com.example.myapp.MainActivity" >
        </activity>
    </application>
</manifest>
```



## Activity

- Represents an entry point for user interaction

- Contains user interfaces

- Mainly runs in the foreground


### Showing an activity

- Activities are made to be invoked without any dependency to other activity (unless configured otherwise)

- Opening an app means invoking an activity in the app to be shown


### Manifest & Activity

- All activity intended to be opened by user must be declared in manifest file

- A manifest of an app should have one default/starting activity for entry point of the app


```
<manifest>
    <application>
        <activity 
            android:name="com.example.myapp.MainActivity" >
        </activity>
    </application>
</manifest>
```


### Activity lifecycle

- An activity has its lifecycle that it follows in response to app's event & framework event

- Developer defines what the activity should do in each lifecycle's event


![lifecycle](https://developer.android.com/guide/components/images/activity_lifecycle.png) <!-- .slide: data-background="#ffffff" -->



## Service

- Represent a running process without user interaction and persist when activity or app is closed

- e.g process that plays music, proces that downloads files in background

- Both background service & foreground service exists

- Types of services from system perspective:
  - Started service
  - Bound service


### Background & Foreground service

- Background service can run without any user-discernable notification

- Foreground service will need to show status bar notification


### Started & Bound service

- Started service is started from other activity & asks the system to let them keep running until self-terminated

- Bound service runs because other apps wants it to run / depends on it thus `bound` its own process to it.



## Broadcast receiver

- Enables the app to receive system-wide broadcast events

- Broadcast events can be originated from the system/OS (e.g event announcing low battery, picture is captured)

- Broadcast event can also be generated by app



## Content provider

- Manages a set of app data that can be queried

- Source can be local file system, network, or other persistent data storage

- Other app can query data from another app's content provider if it allows the data to be shared.

- Data is requested via `ContentResolver`


## Intent

- *Intent* is an abstract data that describes actions to be done by the System or an App

- Intent can be used to start Activities & Services declared in the manifest of an app

- Intent is used as broadcast event

- Type of intent in terms of how it conveys the action target
  - Explicit intent
  - Implicit intent


### Explicit Intent

- Intent initialized with the exact app package name or fully qualified app component class name

```
// Executed in an Activity, so 'this' is the Context
// The fileUrl is a string URL, such as "http://www.example.com/image.png"
val downloadIntent = Intent(this, DownloadService::class.java).apply {
    data = Uri.parse(fileUrl)
}
startService(downloadIntent)
```


### Implicit Intent

- Intent initialized with general action to perform

- If multiple eligible component can receive the action, opens app chooser

```
// Create the text message with a string.
val sendIntent = Intent().apply {
    action = Intent.ACTION_SEND
    putExtra(Intent.EXTRA_TEXT, textMessage)
    type = "text/plain"
}

// Try to invoke the intent.
try {
    startActivity(sendIntent)
} catch (e: ActivityNotFoundException) {
    // Define what your app should do 
    // if no activity can handle the intent.
}

```


![chooser](https://developer.android.com/images/training/basics/intent-chooser.png)


### Intent filter

- The activities & services declared in the manifest can configured to be invoked based on type of intent received

- Implicit intent then can invoke matching app components


```[1-10|4-9|12-23|15-21]
<activity 
    android:name="MainActivity" 
    android:exported="true">
    <intent-filter>
        <action android:name=
            "android.intent.action.MAIN" />
        <category android:name=
            "android.intent.category.LAUNCHER" />
    </intent-filter>
</activity>

<activity android:name="ShareActivity" 
    android:exported="false">

    <intent-filter>
        <action android:name=
            "android.intent.action.SEND"/>
        <category android:name=
            "android.intent.category.DEFAULT"/>
        <data android:mimeType="text/plain"/>
    </intent-filter>
    
</activity>
```



## Creating UI in android

- UI can be created via three ways:

  - Creating layout via XML files and access it at runtime via various ways (Viewbinding, Databinding, Resource loading)

  - Creating layout via Jetpack Compose

  - Creating layout at runtime via view classes

- We will explore how to create class via XML layout and accessing it via viewbinding


### Setup for viewbinding

In build.gradle file
```
android {
    ...
    buildFeatures {
        viewBinding true
    }
}
```


### Example usage
In the activity class
```
private lateinit var binding: ResultProfileBinding

override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    binding = ResultProfileBinding.inflate(layoutInflater)
    val view = binding.root
    setContentView(view)
}
```


## Demo
Simple app w/ one activity & one layout